export default class ScrollableTextBox extends Phaser.GameObjects.Container {
  constructor(scene, x, y, width, height, textString = '', config = {}) {
    super(scene, x, y);
    scene.add.existing(this);

    // === Configuración por defecto ===
    this.config = Object.assign({
      padding: 10,
      fontFamily: 'Arial',
      fontSize: '16px',
      textColor: '#222222',
      backgroundColor: 0xf4f4f4,
      borderColor: 0x7d49aa,
      borderWidth: 2,
      borderRadius: 10,
      scrollSpeed: 0.3
    }, config);

    const { padding, fontFamily, fontSize, textColor, backgroundColor, borderColor, borderWidth, borderRadius } = this.config;

    // === Fondo del cuadro ===
    this.bg = scene.add.graphics();
    this.bg.lineStyle(borderWidth, borderColor, 1);
    this.bg.fillStyle(backgroundColor, 1);
    this.bg.fillRoundedRect(0, 0, width, height, borderRadius);
    this.bg.strokeRoundedRect(0, 0, width, height, borderRadius);

    // === Texto ===
    this.text = scene.add.text(padding, padding, textString, {
      fontFamily,
      fontSize,
      color: textColor,
      wordWrap: { width: width - padding * 2, useAdvancedWrap: true },
      align: 'left'
    });

    // === Máscara de recorte ===
    const maskShape = scene.make.graphics({ add: false });
    maskShape.fillStyle(0xffffff);
    maskShape.fillRect(padding / 2, padding / 2, width - padding, height - padding);
    const mask = maskShape.createGeometryMask();
    this.text.setMask(mask);

    // === Añadir a contenedor ===
    this.add([this.bg, this.text]);

    // === Guardar límites de scroll ===
    this.visibleHeight = height;
    this.scrollY = this.text.y;

    // === Evento de scroll (rueda del ratón) ===
    scene.input.on('wheel', (pointer, gameObjects, deltaX, deltaY) => {
      if (!this.getBounds().contains(pointer.x, pointer.y)) return; // solo scroll si el mouse está encima
      const maxScroll = Math.min(0, height - this.text.height - padding * 2);
      this.text.y -= deltaY * this.config.scrollSpeed;
      this.text.y = Phaser.Math.Clamp(this.text.y, maxScroll, padding);
    });
  }

  /** Cambia el texto del cuadro y reinicia el scroll */
  setText(newText) {
    this.text.setText(newText);
    this.text.y = this.config.padding;
  }

  /** Agrega texto al contenido existente */
  appendText(extraText) {
    this.text.setText(this.text.text + extraText);
  }
}
